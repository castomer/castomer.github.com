<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.82.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta property="og:title" content="关闭kafka java api的log4j配置提升kafka producer性能"><meta name=author content="Dongfang Qu"><meta name=keywords content="kafka,log4j,performance"><meta name=description content="背景 前段时间由于项目需要，基于官方提供的kafka 0.8.1.1版java api开发一个thrift接口的kafka代理层模块，我们暂且就称它为kafka-proxy吧， 主要功能是通过thrift接口接收外部系统的数据，根据规则转发给后端不同的kafka topic。
问 …"><meta property="og:title" content="关闭kafka java api的log4j配置提升kafka producer性能"><meta property="og:description" content="背景 前段时间由于项目需要，基于官方提供的kafka 0.8.1.1版java api开发一个thrift接口的kafka代理层模块，我们暂且就称它为kafka-proxy吧， 主要功能是通过thrift接口接收外部系统的数据，根据规则转发给后端不同的kafka topic。
问题 做为kafka的代理层，QPS非常关键。thrift的server模型选择的TThreadedSelectorServer，在代码完成初期，压测结果很不理想，具体数据如下：
测试条件  cpu: 16 core mem: 128G network: 2 * 1G message_size: 4KB  测试结果  cpu: 194% mem: 4G QPS: 1906 cpu: 230% mem: 4G QPS: 2213  不管怎么压，cpu、内存都占用不高，根据QPS * message_size也可知网卡更不是瓶颈。怎么回事儿呢？
定位  top free jstack  通过jstack dump出jvm进程，发现jvm多个kafka producer线程函数栈waiting for condition在log4j上，基本定位，而且从函数调用栈看起来好像还是默认使用的debug级别，我就擦了～
解决方法 在log4j.properties文件中关闭kafka日志。
log4j.logger.kafka = OFF  此时的QPS可达到2W以上，基本是原来10倍，CPU和网卡成为模块瓶颈。洗洗睡觉～"><meta property="og:type" content="article"><meta property="og:url" content="https://www.concurrent.work/2014/09/15/improve-kafka-producer-api-by-turn-log4j-off/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-09-15T00:00:00+00:00"><meta property="article:modified_time" content="2014-09-15T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="关闭kafka java api的log4j配置提升kafka producer性能"><meta name=twitter:description content="背景 前段时间由于项目需要，基于官方提供的kafka 0.8.1.1版java api开发一个thrift接口的kafka代理层模块，我们暂且就称它为kafka-proxy吧， 主要功能是通过thrift接口接收外部系统的数据，根据规则转发给后端不同的kafka topic。
问题 做为kafka的代理层，QPS非常关键。thrift的server模型选择的TThreadedSelectorServer，在代码完成初期，压测结果很不理想，具体数据如下：
测试条件  cpu: 16 core mem: 128G network: 2 * 1G message_size: 4KB  测试结果  cpu: 194% mem: 4G QPS: 1906 cpu: 230% mem: 4G QPS: 2213  不管怎么压，cpu、内存都占用不高，根据QPS * message_size也可知网卡更不是瓶颈。怎么回事儿呢？
定位  top free jstack  通过jstack dump出jvm进程，发现jvm多个kafka producer线程函数栈waiting for condition在log4j上，基本定位，而且从函数调用栈看起来好像还是默认使用的debug级别，我就擦了～
解决方法 在log4j.properties文件中关闭kafka日志。
log4j.logger.kafka = OFF  此时的QPS可达到2W以上，基本是原来10倍，CPU和网卡成为模块瓶颈。洗洗睡觉～"><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><link rel=stylesheet href=/css/katex.min.css crossorigin=anonymous><script defer src=/js/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=/js/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><title>关闭kafka java api的log4j配置提升kafka producer性能 | Concurrent Work</title></head><body><header><div id=titletext><h2 id=title><a href=https://www.concurrent.work>Concurrent Work</a></h2></div><div id=title-description><p id=subtitle>Rambling of a coder who craves for knowledge and understanding of the world.</p><div id=social><nav><ul><li><a href=https://github.com/qudongfang><i title=Github class="icons fab fa-github"></i></a></li><li><a href=https://www.linkedin.com/in/qudongfang/><i title=LinkedIn class="icons fab fa-linkedin"></i></a></li><li><a href=https://twitter.com/qudongfang><i title=Twitter class="icons fab fa-twitter"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/posts>All Posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/about>About</a></li></ul></nav></div></header><main><div class=post><div class=author><p>Written by Dongfang Qu</p></div><div class=post-header><div class=meta><div class=date><span class=day>15</span>
<span class=rest>Sep 2014</span></div></div><div class=matter><h1 class=title>关闭kafka java api的log4j配置提升kafka producer性能</h1></div></div><div class=markdown><h2 id=背景>背景</h2><p>前段时间由于项目需要，基于官方提供的kafka 0.8.1.1版java api开发一个thrift接口的kafka代理层模块，我们暂且就称它为kafka-proxy吧，
主要功能是通过thrift接口接收外部系统的数据，根据规则转发给后端不同的kafka topic。</p><h2 id=问题>问题</h2><p>做为kafka的代理层，QPS非常关键。thrift的server模型选择的TThreadedSelectorServer，在代码完成初期，压测结果很不理想，具体数据如下：</p><h3 id=测试条件>测试条件</h3><ol><li>cpu: 16 core</li><li>mem: 128G</li><li>network: 2 * 1G</li><li>message_size: 4KB</li></ol><h3 id=测试结果>测试结果</h3><ol><li>cpu: 194% mem: 4G QPS: 1906</li><li>cpu: 230% mem: 4G QPS: 2213</li></ol><p>不管怎么压，cpu、内存都占用不高，根据QPS * message_size也可知网卡更不是瓶颈。怎么回事儿呢？</p><h2 id=定位>定位</h2><ol><li><code>top</code></li><li><code>free</code></li><li><code>jstack</code></li></ol><p>通过jstack dump出jvm进程，发现jvm多个kafka producer线程函数栈waiting for condition在log4j上，基本定位，而且从函数调用栈看起来好像还是默认使用的debug级别，我就擦了～</p><h2 id=解决方法>解决方法</h2><p>在log4j.properties文件中关闭kafka日志。</p><pre><code>log4j.logger.kafka = OFF
</code></pre><p>此时的QPS可达到2W以上，基本是原来10倍，CPU和网卡成为模块瓶颈。洗洗睡觉～</p></div><div class=tags><div class=taxosfloating_left><p>Categories</p></div><div class=termsfloating_right><p><a href=/categories/kafka/>kafka</a></p></div><div class=clearit></div><div class=tags><div class=taxosfloating_left><p>Tags</p></div><div class=termsfloating_right><p><a href=/tags/kafka/>kafka</a>
<a href=/tags/log4j/>log4j</a>
<a href=/tags/performance/>performance</a></p></div><div class=clearit></div></div></div></main><footer>©Copyright | <a href=https://github.com/qudongfang/>Concurrent work</a></footer></body></html>