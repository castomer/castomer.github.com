<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>docker on Concurrent Work</title><link>http://concurrent.work/tags/docker/</link><description>Recent content in docker on concurrent.work</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>©Copyright | Concurrent work</copyright><lastBuildDate>Thu, 19 Jul 2018 00:00:00 +0000</lastBuildDate><atom:link href="http://concurrent.work/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>容器(docker)中运行java需关注的几个小问题</title><link>http://concurrent.work/2018/07/19/pitfalls-about-running-java-inside-container/</link><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><guid>http://concurrent.work/2018/07/19/pitfalls-about-running-java-inside-container/</guid><description>
简介 container： 资源隔离、平台无关， 限制cpu、mem等资源
Java： 平台无关、Write once, run anywhere、WORA
java不知道自己运行在container里，以为它看到的资源都能用。结果：java …</description></item><item><title>容器内外统一的taskset命令</title><link>http://concurrent.work/2016/10/23/unified-process-cpu-taskset-cmd-used-within-and-outside-container/</link><pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate><guid>http://concurrent.work/2016/10/23/unified-process-cpu-taskset-cmd-used-within-and-outside-container/</guid><description>
监控业务agent部署时，为避免影响业务方计算资源，一般会对agent做cpu taskset限制。 现在遇到的问题是，agent的启动环境复杂，对于tasket来说物理机和虚拟机都很简单。然而容器就不同了， 许多种container解决方案下，容器内的进程看到的cpu都是其宿主 …</description></item></channel></rss>